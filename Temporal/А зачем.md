# Монолитная архитектура
В данном подходе один сервер приложения общается с одной базой данных. Всё состояние централизованно в БД, все его изменения происходят внутри транзакций. Транзакция либо завершается успешно и мы делаем ```COMMIT```, или неуспешно - мы делаем ```ROLLBACK``` и возвращаем состояние на момент начала транзакции. Это даёт нам следующее преимущество: никакая операция не может "застрять посередине", уже изменив общее состояние, но не доведя его до полной согласованности и не выполнив весь объём необходимой работы.
# Микросервисы
При использовании микросервисной архитектуры монолит разбивается на несколько отдельных самодостаточных сервисов небольшого размера. Каждый микросервис отвечает за отдельную часть предметной области, и, следовательно, имеет собственную базу данных.

Возникает проблема - общее состояние системы распределено по множеству микросервисов. Обновление состояния требует последовательного изменения сразу в нескольких базах данных. Это требует взаимодействия микросервисов между собой, когда каждый сервис отвечает за свою часть логики.

При этом в больших системах часто присутствуют операции, которые реализуют длительные бизнес-процессы. Они затрагивают множество внутренних систем, обращаются ко внешним сервисам, могут требовать взаимодействия с человеком (подтверждение операции, ввод данных, и т. д.), содержат сложную условную логику и циклы.

Во время выполнения подобных бизнес-процессов микросервисы общаются между собой по сети, что становится местом потенциального отказа. Но откатить транзакцию просто так уже не получится: изменение происходит сразу в нескольких базах данных, а процесс на момент сбой мог уже выполняться очень длительное время.

Решением проблемы может быть перезапуск неудачно завершившегося процесса, при этом необходимо избежать повторного выполнения операций, произошедших до момента сбоя. Для этого можно для каждого процесса хранить текущее состояние его выполнения и в коде приложения для каждой операции проверять выполнилась она или нет. При таком подходе возникает большое количество boilerplate-кода, связанного с хранением состояния процесса и его последующим восстановлением.
# Temporal
Temporal предоставляет механизм для решения проблемы отказоустойчивого выполнения длительных бизнес-процессов  в системах с микросервисной архитектурой.

В Temporal код приложения всё так же находится и выполняется в микросервисах. Но дополнительно запускается Temporal Cluster. Он хранит в себе состояние всех запущенных процессов, оркестрирует их выполнение, ведёт историю изменений для каждого процесса. Если какой-то этап процесса завершается с ошибкой, Temporal автоматически пытается выполнить этот этап повторно. При отказе любой части системы (сам Temporal Cluster или пользовательские сервисы) состояние каждого запущенного процесса восстанавливается, и они повторно запускаются с того момента, на котором произошёл сбой.

При этом код для бизнес-процессов пишется на обычном языке программирования, и в нём не нужно делать дополнительных проверок не предмет восстановления или повторного запуска при сбое. За всё это отвечает Temporal SDK, которая поставляется для большинства популярных языков программирования.